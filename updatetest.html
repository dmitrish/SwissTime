<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing In-App Updates: Implementation and Best Practices</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fafafa;
            color: #333;
        }
        
        h1 {
            color: #1976d2;
            border-bottom: 3px solid #1976d2;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #424242;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        h3 {
            color: #666;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .objective {
            background-color: #e3f2fd;
            border-left: 4px solid #1976d2;
            padding: 15px;
            margin-bottom: 25px;
            font-style: italic;
        }
        
        code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #d32f2f;
        }
        
        pre {
            border-radius: 5px;
            margin: 15px 0;
        }
        
        pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.85em;
            line-height: 1.4;
        }
        
        .code-block {
            margin: 15px 0;
        }
        
        ul {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .important {
            background-color: #fff3e0;
            border-left: 4px solid #f57c00;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        .section {
            margin-bottom: 30px;
        }
        
        .highlight {
            background-color: #ffeb3b;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .framework-info {
            background-color: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .layoutlib-info {
            background-color: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .update-info {
            background-color: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .test-info {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
            font-size: 0.85em;
        }
        
        .comparison-table th {
            background-color: #f5f5f5;
            font-weight: bold;
            color: #333;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .comparison-table tr:hover {
            background-color: #f0f8ff;
        }
        
        .framework-name {
            font-weight: bold;
            color: #1976d2;
        }
        
        .github-link {
            color: #0066cc;
            text-decoration: none;
            font-size: 0.9em;
        }
        
        .github-link:hover {
            text-decoration: underline;
        }
        
        .check-mark {
            color: #4caf50;
            font-weight: bold;
        }
        
        .x-mark {
            color: #f44336;
            font-weight: bold;
        }
        
        .partial-mark {
            color: #ff9800;
            font-weight: bold;
        }
        
        .topic-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .key-insight {
            background-color: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pros {
            background-color: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 15px;
            border-radius: 5px;
        }
        
        .cons {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px;
            border-radius: 5px;
        }
        
        .pros h4, .cons h4 {
            margin-top: 0;
            color: #333;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .feature-card h4 {
            margin-top: 0;
            color: #1976d2;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
        }
        
        .architecture-diagram {
            background-color: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            text-align: center;
        }
        
        .workflow-step {
            background-color: #e3f2fd;
            border-left: 4px solid #1976d2;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .workflow-step strong {
            color: #1976d2;
        }
        
        .final-recommendation {
            background-color: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }
        
        .final-recommendation h3 {
            color: #2e7d32;
            margin-top: 0;
        }
        
        .use-case-card {
            background-color: #f8f9fa;
            border-left: 4px solid #6c757d;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .use-case-card h4 {
            margin-top: 0;
            color: #495057;
        }

        .flow-diagram {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
        }

        .flow-step {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .flow-step:not(:last-child)::after {
            content: '‚Üì';
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #1976d2;
            font-weight: bold;
        }

        .step-left, .step-right {
            flex: 1;
            padding: 0 15px;
        }

        .step-left {
            text-align: right;
            border-right: 3px solid #e74c3c;
            color: #e74c3c;
        }

        .step-right {
            text-align: left;
            border-left: 3px solid #27ae60;
            color: #27ae60;
        }

        .step-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .step-desc {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .vs-arrow {
            font-size: 24px;
            color: #1976d2;
            font-weight: bold;
            margin: 0 20px;
        }
        
        @media (max-width: 768px) {
            .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }

            .flow-step {
                flex-direction: column;
                text-align: center;
            }
            
            .step-left, .step-right {
                border: none;
                border-top: 3px solid #1976d2;
                margin: 10px 0;
                padding-top: 15px;
            }
            
            .vs-arrow {
                transform: rotate(90deg);
                margin: 10px 0;
            }
        }
    </style>
</head>
<body>
    <h1>Testing In-App Updates: Implementation and Best Practices</h1>
    
    <div class="objective">
        <strong>Implementation Summary:</strong> A comprehensive technical analysis of implementing and testing Google Play's in-app update functionality in the SwissTime app, focusing on the challenges of testing without requiring the app to be installed from the Play Store and the solution using FakeAppUpdateManager.
    </div>

    <div class="section">
        <h2>Overview & Challenge</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h4>The In-App Update Challenge</h4>
                <div class="update-info">
                    <strong>Purpose:</strong> Seamless app updates without leaving the app<br>
                    <strong>Used by:</strong> SwissTime app for version updates<br>
                    <strong>Core Technology:</strong> Google Play Core library<br>
                    <strong>Primary Benefit:</strong> Improved user experience and update adoption
                </div>
                <p>In-app updates allow users to update their apps without leaving the app and going to the Play Store. This improves the user experience and increases update adoption rates. However, testing this functionality presents unique challenges, especially in development environments.</p>
            </div>
            
            <div class="feature-card">
                <h4>The Testing Problem</h4>
                <div class="test-info">
                    <strong>Problem:</strong> Real AppUpdateManager requires Play Store installation<br>
                    <strong>Error Message:</strong> "App is not owned by any user on this device"<br>
                    <strong>Development Constraint:</strong> Direct installs can't test update flow<br>
                    <strong>Solution:</strong> FakeAppUpdateManager from Play Core testing library
                </div>
                <p>The standard AppUpdateManager from Google's Play Core library requires the app to be installed from the Play Store to function properly. During development, when apps are directly installed from Android Studio, the update check fails with the message "App is not owned by any user on this device." This makes testing the update flow challenging without publishing to the Play Store.</p>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Implementation Approach</h2>
        
        <div class="topic-section">
            <h3>Architecture Comparison</h3>
            <div class="architecture-diagram">
                Real Implementation ‚Üí AppUpdateManager ‚Üí Play Core Library ‚Üí Google Play Store ‚Üí App Update
                <br><br>
                <strong>Dependencies:</strong><br>
                ‚îå‚îÄ App installed from Play Store<br>
                ‚îú‚îÄ Google Play Services<br>
                ‚îú‚îÄ Internet connection<br>
                ‚îî‚îÄ Valid Google account
            </div>
            
            <h3>Test Implementation</h3>
            <div class="architecture-diagram">
                Test Implementation ‚Üí TestAppUpdateManager ‚Üí FakeAppUpdateManager ‚Üí Simulated Update Flow ‚Üí No Play Store Required
                <br><br>
                <strong>Dependencies:</strong><br>
                ‚îî‚îÄ Play Core testing library only
            </div>
            
            <div class="key-insight">
                <strong>Key Architectural Innovation:</strong> Our testing approach doesn't try to mock or bypass the Play Store requirements. Instead, it provides a complete alternative implementation using Google's official FakeAppUpdateManager that simulates the entire update flow without requiring the app to be installed from the Play Store.
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Implementation Details</h2>
        
        <div class="topic-section">
            <div class="flow-diagram">
                <div class="flow-step">
                    <div class="step-left">
                        <div class="step-title">Real AppUpdateManager</div>
                        <div class="step-desc">Requires Play Store installation<br/>‚Üí Checks with Google Play servers<br/>‚Üí Real update packages</div>
                    </div>
                    <div class="vs-arrow">‚ö°</div>
                    <div class="step-right">
                        <div class="step-title">FakeAppUpdateManager</div>
                        <div class="step-desc">Works with any installation<br/>‚Üí Simulates update availability<br/>‚Üí Controlled test environment</div>
                    </div>
                </div>

                <div class="flow-step">
                    <div class="step-left">
                        <div class="step-title">Production Code</div>
                        <div class="step-desc">AppUpdateManager from Play Core<br/>‚Üí Real update flows<br/>‚Üí Actual app updates</div>
                    </div>
                    <div class="vs-arrow">üîÑ</div>
                    <div class="step-right">
                        <div class="step-title">Test Code</div>
                        <div class="step-desc">TestAppUpdateManager wrapper<br/>‚Üí Same interface as real implementation<br/>‚Üí Simulated update states</div>
                    </div>
                </div>

                <div class="flow-step">
                    <div class="step-left">
                        <div class="step-title">Update Verification</div>
                        <div class="step-desc">Manual testing<br/>‚Üí Real device required<br/>‚Üí Slow feedback loop</div>
                    </div>
                    <div class="vs-arrow">üñ•Ô∏è</div>
                    <div class="step-right">
                        <div class="step-title">Automated Testing</div>
                        <div class="step-desc">Instrumented tests<br/>‚Üí Programmatic verification<br/>‚Üí Fast feedback loop</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Implementation Components</h2>

        <div class="feature-grid">
            <div class="feature-card">
                <h4>1. Dependencies</h4>
                <p>First, we added the Play Core testing library to our project's build.gradle.kts file:</p>
                
                <div class="code-block">
                    <pre><code class="kotlin">// app/build.gradle.kts
dependencies {
    // Existing dependencies...
    
    // Play Core for in-app updates
    implementation(libs.app.update)
    implementation(libs.app.update.ktx)
    
    // Play Core testing library for FakeAppUpdateManager
    debugImplementation("com.google.android.play:app-update-testing:2.1.0")
}</code></pre>
                </div>
                <p>This gives us access to the FakeAppUpdateManager class, which is the foundation of our testing approach.</p>
            </div>

            <div class="feature-card">
                <h4>2. TestAppUpdateManager</h4>
                <p>We created a TestAppUpdateManager class that wraps the FakeAppUpdateManager and provides the same interface as our real AppUpdateManager:</p>
                
                <div class="code-block">
                    <pre><code class="kotlin">class TestAppUpdateManager(
    private val activity: Activity,
    private val coroutineScope: CoroutineScope,
    private val fakeAppUpdateManager: FakeAppUpdateManager
) : DefaultLifecycleObserver {

    // State flows to observe update status
    private val _updateStatus = MutableStateFlow&lt;UpdateStatus>(UpdateStatus.Idle)
    val updateStatus: StateFlow&lt;UpdateStatus> = _updateStatus.asStateFlow()

    // Methods for checking updates, handling lifecycle events, etc.
    fun checkForUpdate(forceImmediateUpdate: Boolean = false) {
        _updateStatus.value = UpdateStatus.Checking
        
        val appUpdateInfoTask = fakeAppUpdateManager.appUpdateInfo
        appUpdateInfoTask.addOnSuccessListener { appUpdateInfo ->
            // Implementation similar to real AppUpdateManager
            // but using fakeAppUpdateManager instead
        }
    }
    
    // Other methods matching the real AppUpdateManager interface
}</code></pre>
                </div>
                <p>This class mimics the behavior of our real AppUpdateManager but uses the FakeAppUpdateManager internally, allowing us to test the update flow without requiring the app to be installed from the Play Store.</p>
            </div>

            <div class="feature-card">
                <h4>3. Test Cases</h4>
                <p>We implemented comprehensive test cases in AppUpdateTest.kt to verify different update scenarios:</p>
                
                <div class="code-block">
                    <pre><code class="kotlin">@RunWith(AndroidJUnit4::class)
class AppUpdateTest {

    private lateinit var fakeAppUpdateManager: FakeAppUpdateManager
    private lateinit var testAppUpdateManager: TestAppUpdateManager
    
    @Before
    fun setup() {
        // Setup code...
    }

    @Test
    fun testFlexibleUpdate_Completes() = runBlocking {
        // Setup flexible update
        fakeAppUpdateManager.setUpdateAvailable(2) // Higher version code
        fakeAppUpdateManager.setUpdatePriority(2) // Medium priority
        
        // Check for updates
        testAppUpdateManager.checkForUpdate()
        
        // Verify update status and simulate user actions
        assertEquals(TestAppUpdateManager.UpdateStatus.Checking, 
                    testAppUpdateManager.updateStatus.first())
        
        fakeAppUpdateManager.userAcceptsUpdate()
        fakeAppUpdateManager.downloadStarts()
        fakeAppUpdateManager.downloadCompletes()
        
        // Verify final status
        assertEquals(TestAppUpdateManager.UpdateStatus.Downloaded, 
                    testAppUpdateManager.updateStatus.first())
    }
    
    // Additional test cases for different scenarios
}</code></pre>
                </div>
                <p>These tests cover various scenarios including flexible updates, immediate updates, failed updates, and user cancellations.</p>
            </div>

            <div class="feature-card">
                <h4>4. Documentation</h4>
                <p>We created comprehensive documentation in README.md to explain how to use the testing implementation:</p>
                
                <div class="code-block">
                    <pre><code class="markdown"># Testing In-App Updates with FakeAppUpdateManager

This document explains how to use the `FakeAppUpdateManager` to test 
in-app updates in the SwissTime app without requiring the app to be 
installed from the Play Store.

## Overview

The SwissTime app uses Google Play's in-app update API to provide 
seamless updates to users. Testing this functionality can be 
challenging because:

1. The real `AppUpdateManager` requires the app to be installed from 
   the Play Store
2. It's difficult to simulate different update scenarios

To address these challenges, we've implemented a testing approach 
using Google's `FakeAppUpdateManager` from the Play Core testing 
library.

## Implementation

The testing implementation consists of two main components:

1. **TestAppUpdateManager**: A test-specific version of our custom 
   `AppUpdateManager` that accepts a `FakeAppUpdateManager` instance
2. **AppUpdateTest**: A test class that demonstrates how to use 
   `TestAppUpdateManager` to test different update scenarios

...</code></pre>
                </div>
                <p>This documentation serves as a guide for developers who need to test the in-app update functionality in the future.</p>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Key Implementation Decisions</h2>

        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Decision Point</th>
                    <th>Options Considered</th>
                    <th>Chosen Approach</th>
                    <th>Rationale</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Testing Approach</strong></td>
                    <td>1. Manual testing with Play Store<br>2. Internal app sharing<br>3. FakeAppUpdateManager</td>
                    <td>FakeAppUpdateManager</td>
                    <td>Provides automated testing without requiring Play Store installation</td>
                </tr>
                <tr>
                    <td><strong>Implementation Structure</strong></td>
                    <td>1. Direct use of FakeAppUpdateManager<br>2. Custom wrapper class</td>
                    <td>Custom TestAppUpdateManager wrapper</td>
                    <td>Maintains same interface as real implementation for consistent testing</td>
                </tr>
                <tr>
                    <td><strong>Test Scenarios</strong></td>
                    <td>1. Basic update flow only<br>2. Comprehensive scenarios</td>
                    <td>Comprehensive test scenarios</td>
                    <td>Covers all possible update paths including failures and cancellations</td>
                </tr>
                <tr>
                    <td><strong>Status Tracking</strong></td>
                    <td>1. Callbacks<br>2. StateFlow</td>
                    <td>StateFlow</td>
                    <td>Consistent with real implementation and easier to test with Kotlin coroutines</td>
                </tr>
                <tr>
                    <td><strong>Documentation</strong></td>
                    <td>1. Code comments only<br>2. Separate documentation</td>
                    <td>Comprehensive README.md</td>
                    <td>Provides clear guidance for future developers</td>
                </tr>
            </tbody>
        </table>

        <div class="key-insight">
            <strong>Critical Insight:</strong> By creating a TestAppUpdateManager that has the same interface as our real AppUpdateManager, we ensure that our tests accurately reflect the behavior of the production code. This approach allows us to test the update flow without modifying our production code or requiring the app to be installed from the Play Store.
        </div>
    </div>

    <div class="section">
        <h2>Testing Scenarios</h2>

        <div class="topic-section">
            <h3>Comprehensive Test Coverage</h3>
            
            <div class="code-block">
                <pre><code class="kotlin">// 1. Flexible Update - Complete Flow
@Test
fun testFlexibleUpdate_Completes() = runBlocking {
    // Setup flexible update
    fakeAppUpdateManager.setUpdateAvailable(2)
    fakeAppUpdateManager.setUpdatePriority(2)
    
    // Check for updates
    testAppUpdateManager.checkForUpdate()
    
    // Simulate user accepting the update
    fakeAppUpdateManager.userAcceptsUpdate()
    
    // Simulate download starting and completing
    fakeAppUpdateManager.downloadStarts()
    fakeAppUpdateManager.downloadCompletes()
    
    // Complete the update
    testAppUpdateManager.completeUpdate()
    
    // Simulate install completing
    fakeAppUpdateManager.installCompletes()
    
    // Verify final status
    assertEquals(TestAppUpdateManager.UpdateStatus.Installed, 
                testAppUpdateManager.updateStatus.first())
}

// 2. Immediate Update - Complete Flow
@Test
fun testImmediateUpdate_Completes() = runBlocking {
    // Setup immediate update
    fakeAppUpdateManager.setUpdateAvailable(2)
    fakeAppUpdateManager.setUpdatePriority(5)
    
    // Check for updates and verify flow
    // ...
}

// 3. Failed Update
@Test
fun testFlexibleUpdate_DownloadFails() = runBlocking {
    // Setup update
    fakeAppUpdateManager.setUpdateAvailable(2)
    
    // Simulate failure
    fakeAppUpdateManager.downloadFails()
    
    // Verify failure status
    // ...
}

// 4. No Update Available
@Test
fun testNoUpdateAvailable() = runBlocking {
    // Setup no update
    fakeAppUpdateManager.setUpdateNotAvailable()
    
    // Verify correct status
    // ...
}

// 5. User Cancellation
@Test
fun testUpdateCanceled() = runBlocking {
    // Setup update
    fakeAppUpdateManager.setUpdateAvailable(2)
    
    // Simulate user cancellation
    fakeAppUpdateManager.userRejectsUpdate()
    
    // Verify cancellation status
    // ...
}</code></pre>
            </div>

            <h3>Status Verification</h3>
            
            <div class="code-block">
                <pre><code class="kotlin">// Verifying update status at each step
runBlocking {
    // Verify initial status
    assertEquals(TestAppUpdateManager.UpdateStatus.Checking, 
                testAppUpdateManager.updateStatus.first())
    
    // After user accepts
    fakeAppUpdateManager.userAcceptsUpdate()
    
    // During download
    fakeAppUpdateManager.downloadStarts()
    assertTrue(testAppUpdateManager.updateStatus.first() is 
              TestAppUpdateManager.UpdateStatus.Downloading)
    
    // After download completes
    fakeAppUpdateManager.downloadCompletes()
    assertEquals(TestAppUpdateManager.UpdateStatus.Downloaded, 
                testAppUpdateManager.updateStatus.first())
    
    // After installation
    testAppUpdateManager.completeUpdate()
    assertEquals(TestAppUpdateManager.UpdateStatus.Installing, 
                testAppUpdateManager.updateStatus.first())
}</code></pre>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Benefits & Limitations</h2>

        <div class="pros-cons">
            <div class="pros">
                <h4>Benefits ‚úì</h4>
                <ul>
                    <li><strong>No Play Store Requirement:</strong> Test update flows without installing from Play Store</li>
                    <li><strong>Automated Testing:</strong> Integrate with CI/CD pipelines for automated verification</li>
                    <li><strong>Comprehensive Scenarios:</strong> Test all update paths including failures and edge cases</li>
                    <li><strong>Fast Feedback Loop:</strong> Quick verification without publishing to Play Store</li>
                    <li><strong>Controlled Environment:</strong> Simulate specific update conditions and user behaviors</li>
                    <li><strong>Consistent Interface:</strong> Same API as real implementation for accurate testing</li>
                    <li><strong>Official Google Solution:</strong> Uses Google's recommended testing approach</li>
                </ul>
            </div>
            
            <div class="cons">
                <h4>Limitations ‚úó</h4>
                <ul>
                    <li><strong>Not Real Updates:</strong> Simulated updates don't actually update the app</li>
                    <li><strong>Play Store Differences:</strong> May not catch Play Store-specific issues</li>
                    <li><strong>UI Interaction Limitations:</strong> Limited testing of UI interactions with update dialogs</li>
                    <li><strong>Version-Specific Behavior:</strong> Play Core library updates may change behavior</li>
                    <li><strong>Device Variations:</strong> May not catch device-specific update issues</li>
                    <li><strong>Network Conditions:</strong> Limited simulation of real-world network conditions</li>
                    <li><strong>Final Verification Needed:</strong> Still requires manual testing before release</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Usage Examples</h2>

        <div class="feature-grid">
            <div class="feature-card">
                <h4>Basic Test Setup</h4>
                <div class="test-info">
                    <strong>Purpose:</strong> Basic test configuration<br>
                    <strong>Key Components:</strong> FakeAppUpdateManager, TestAppUpdateManager<br>
                    <strong>Usage:</strong> Foundation for all update tests
                </div>
                
                <div class="code-block">
                    <pre><code class="kotlin">@Before
fun setup() {
    // Launch the main activity
    val activityScenario = ActivityScenario.launch(MainActivity::class.java)
    
    // Get the activity instance
    activityScenario.onActivity { 
        activity = it
        
        // Create a FakeAppUpdateManager with the activity context
        fakeAppUpdateManager = FakeAppUpdateManager(activity)
        
        // Create a TestAppUpdateManager with the FakeAppUpdateManager
        testAppUpdateManager = TestAppUpdateManager(
            activity = activity,
            coroutineScope = CoroutineScope(Dispatchers.Main),
            fakeAppUpdateManager = fakeAppUpdateManager
        )
    }
}</code></pre>
                </div>
            </div>

            <div class="feature-card">
                <h4>Testing Flexible Updates</h4>
                <div class="update-info">
                    <strong>Scenario:</strong> Flexible update flow<br>
                    <strong>Key Steps:</strong> Setup, check, accept, download, complete<br>
                    <strong>Verification:</strong> Status transitions
                </div>
                
                <div class="code-block">
                    <pre><code class="kotlin">@Test
fun testFlexibleUpdate_Completes() = runBlocking {
    // Setup flexible update
    fakeAppUpdateManager.setUpdateAvailable(2)
    fakeAppUpdateManager.setUpdatePriority(2)
    
    // Check for updates
    testAppUpdateManager.checkForUpdate()
    
    // Simulate user accepting the update
    fakeAppUpdateManager.userAcceptsUpdate()
    
    // Simulate download starting and completing
    fakeAppUpdateManager.downloadStarts()
    fakeAppUpdateManager.downloadCompletes()
    
    // Complete the update
    testAppUpdateManager.completeUpdate()
    
    // Simulate install completing
    fakeAppUpdateManager.installCompletes()
    
    // Verify final status
    assertEquals(TestAppUpdateManager.UpdateStatus.Installed, 
                testAppUpdateManager.updateStatus.first())
}</code></pre>
                </div>
            </div>
        </div>
    </div>

    <div class="final-recommendation">
        <h3>üîë Key Takeaways</h3>
        
        <p><strong>Our implementation of in-app update testing represents a practical solution to a common development challenge</strong> - how to test functionality that depends on the Play Store without actually requiring the app to be installed from the Play Store.</p>
        
        <div class="key-insight">
            <strong>The Core Innovation:</strong> Rather than trying to work around the Play Store requirements, we've embraced Google's official testing solution - FakeAppUpdateManager - and built a comprehensive testing framework around it. This approach allows us to test all aspects of the update flow in an automated way, without compromising the integrity of our production code.
        </div>
        
        <h4>Key Takeaways:</h4>
        <ul>
            <li><strong>Consistent Interface:</strong> TestAppUpdateManager maintains the same interface as our real AppUpdateManager</li>
            <li><strong>Comprehensive Testing:</strong> Our tests cover all update scenarios including success, failure, and cancellation</li>
            <li><strong>Developer Experience:</strong> Clear documentation makes it easy for future developers to understand and use the testing approach</li>
            <li><strong>Automation Ready:</strong> Tests can be integrated into CI/CD pipelines for automated verification</li>
            <li><strong>Official Solution:</strong> Using Google's recommended approach ensures compatibility with future Play Core updates</li>
        </ul>
        
        <div class="important">
            <strong>Bottom Line:</strong> Our implementation of in-app update testing transforms a manual, Play Store-dependent process into an automated, reliable testing workflow. This approach saves development time, improves code quality, and ensures that our in-app update functionality works correctly in all scenarios.
        </div>
    </div>

    <script>
        // Initialize syntax highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>